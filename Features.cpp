#include "stdafx.h"
#include "Resource.h"
#include "GlobalVars.h"
#include "Features.h"
#include "InternalMemoryDefaults.h"
#include "cb_FileVersion.h"


CFeatures::CFeatures(void)
{
	InitFeatureData();
	LoadDefaults();
	m_sUnknown = _T("");
}

CFeatures::~CFeatures(void)
{
}

// Public functions
BOOL CFeatures::Read(CString sFile)
{
	// TRUE if successfully read, FALSE otherwise
	BOOL fRet = TRUE;

	TRY
	{
		CString sCompleteFile;
		sCompleteFile = ReadEntireFile(sFile);
		if ( sCompleteFile.IsEmpty() )
		{
			AfxThrowUserException();
		}

		// clear out all the existing values
		Clear();
		// now process the file
		/*
		Search for #define
		when found, look at the previous 2 chars
			if they are //, then we ignore the #define line and move on
			if they are a space, tab, \r\n, then we process the define statement
		process the #define
			grab the chars between spaces and save the text
			if the text requires a parameter, then read the parameter in
		*/
		int pos = 0;
		int npos = 0;
		CString sTokenString;
		sTokenString.LoadString(IDS_NEWLINE);
		CString sWhiteSpace;
		sWhiteSpace.LoadString(IDS_WHITESPACE);
		CString sCRLF;
		sCRLF.LoadString(IDS_CRLF);
		CString token;
		CString token2;
		token = sCompleteFile.Tokenize(sTokenString, pos);
		while ( token != _T("") )
		{
			// process token
			token.TrimLeft(sWhiteSpace);
			token.TrimRight(sCRLF);
			// split the line up into spaces if it begins with #define
			if ( token.Left(7) == _T("#define") )
			{
				token = token.Mid(7);
				// have a define line
				npos = 0;
				int count = 0;
				CString ptoken = _T("");
				token2 = token.Tokenize(sWhiteSpace, npos);
				while ( token2 != _T("") )
				{
					TRACE("t:  '%s'\n", token2);
					count++;
					if ( count == 1 )
					{
						ProcessFeature(token2);
						ptoken = token2;
					} else 
					{
						if ( count == 2 )
						{
							ProcessFeature(ptoken, token2);
						}
					}
					token2 = token.Tokenize(sWhiteSpace, npos);
				}
			}
			token = sCompleteFile.Tokenize(sTokenString, pos);
		}
	}
	CATCH_ALL(e)
	{
		CString sBuffer;
		TCHAR szMsg[255];
		e->GetErrorMessage(szMsg, 255);
		sBuffer.Format(_T("Unable to read Features file:\n\n"));
		sBuffer += szMsg;
		//AfxMessageBox(sBuffer, MB_ICONINFORMATION);
		TRACE("%s", sBuffer);
		fRet = FALSE;
	}
	END_CATCH_ALL

	return fRet;
}

BOOL CFeatures::Write(CString sLibraryFolder)
{
	BOOL bRet = FALSE;

	TRY
	{
		CString s;
		CTime t = CTime::GetCurrentTime();
		CString sAutoGenHeader;
		sAutoGenHeader.Format(_T("// AutoGenerated file by RAGen (v%s), (%s)\r\n\r\n"),
				cb_GetFileVersionString(AfxGetInstanceHandle()),
				t.Format("%m/%d/%Y %H:%M"));
		CString sHeader = _T("\
/*\r\n\
 * Copyright 2010-12 Curt Binder\r\n\
 *\r\n\
 * Licensed under the Apache License, Version 2.0 (the \"License\")\r\n\
 * you may not use this file except in compliance with the License.\r\n\
 * You may obtain a copy of the License at\r\n\
 *\r\n\
 * http://www.apache.org/licenses/LICENSE-2.0\r\n\
 *\r\n\
 * Unless required by applicable law or agreed to in writing, software\r\n\
 * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n\
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\
 * See the License for the specific language governing permissions and\r\n\
 * limitations under the License.\r\n\
 */\r\n\
\r\n\r\n\
#ifndef __REEFANGEL_FEATURES_H__\r\n\
#define __REEFANGEL_FEATURES_H__\r\n\
\r\n\r\n\
");
		CString sFooter = _T("\r\n\r\n#endif  // __REEFANGEL_FEATURES_H__\r\n");
		CString sFile;
		sFile.Format(_T("%s\\ReefAngel_Features\\"), sLibraryFolder);
		SECURITY_ATTRIBUTES sa;
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;
		sa.bInheritHandle = FALSE;
		int iRet = SHCreateDirectoryEx(NULL, sFile, &sa);
		if ( iRet != ERROR_SUCCESS )
		{
			DWORD dw = GetLastError();
			if ( (dw != ERROR_FILE_EXISTS) && (dw != ERROR_ALREADY_EXISTS) )
			{
				// An unknown error has occurred
				AfxThrowUserException();
			}
		}
		sFile += _T("ReefAngel_Features.h");
		CFile f;
		f.Open(sFile, CFile::modeCreate | CFile::modeWrite);
		f.Write(sAutoGenHeader, sAutoGenHeader.GetLength());
		f.Write(sHeader, sHeader.GetLength());
		s = GetEnabledList();
		f.Write(s, s.GetLength());
		// if we have any additional features, prompt if the user wants to keep them or not
		if ( ! m_sUnknown.IsEmpty() )
		{
			s.Format(_T("Additional unrecognized features found.\n\n%s\nDo you want to keep them in your Features file?\n(Yes - keeps, No - clears & cannot be undone)"),
				m_sUnknown);
			if ( AfxMessageBox(s, MB_ICONQUESTION|MB_YESNO) == IDNO )
			{
				m_sUnknown = _T("");
			}
			else
			{
				f.Write(m_sUnknown, m_sUnknown.GetLength());
			}
		}
		f.Write(sFooter, sFooter.GetLength());
		f.Close();
		bRet = TRUE;
	}
	CATCH_ALL(e)
	{
		CString sBuffer;
		TCHAR szMsg[255];
		e->GetErrorMessage(szMsg, 255);
		sBuffer.Format(_T("Unable to generate ReefAngel_Features.h:\n\n"));
		sBuffer += szMsg;
		AfxMessageBox(sBuffer, MB_ICONINFORMATION);
		bRet = FALSE;
	}
	END_CATCH_ALL

	return bRet;
}

void CFeatures::ShowUnknownFeatures()
{
	CString s;
	if ( m_sUnknown.IsEmpty() )
	{
		s.LoadString(IDS_NO_UNKNOWN_FEATURES);
	}
	else
	{
		s.Format(IDS_UNKNOWN_FEATURES, m_sUnknown);
	}
	AfxMessageBox(s, MB_ICONINFORMATION|MB_OK);
}

void CFeatures::LoadDefaults()
{
	// clear the values first
	Clear();

	// now set the defaults
	SetFeatureValue(DISPLAY_IMAGES, TRUE);
	SetFeatureValue(DATE_TIME_SETUP, TRUE);
	SetFeatureValue(VERSION_MENU, TRUE);
	SetFeatureValue(DIRECT_TEMP_SENSOR, TRUE);
	SetFeatureValue(DISPLAY_LED_PWM, TRUE);
	SetFeatureValue(WIFI, TRUE);
	SetFeatureValue(SIMPLE_MENU, TRUE);
	iInstalledExpansionModules = 0;
	iCustomMenuEntries = MENU_DEFAULT;
}

BOOL CFeatures::IsDefaultEnabledFeature(int featureID)
{
	if ( (featureID == DISPLAY_IMAGES) ||
		 (featureID == DATE_TIME_SETUP) ||
		 (featureID == VERSION_MENU) ||
		 (featureID == DIRECT_TEMP_SENSOR) ||
		 (featureID == DISPLAY_LED_PWM) ||
		 (featureID == WIFI) ||
		 (featureID == SIMPLE_MENU) )
	{
		return TRUE;
	}
	return FALSE;
}

void CFeatures::Clear()
{
	// first real feature starts at 1
	for ( int i = 1; i < MAX_FEATURES; i++ )
	{
		SetFeatureValue(i, FALSE);
	}

	iInstalledExpansionModules = 0;
	iCustomMenuEntries = 1;
}

void CFeatures::CleanupFeatures()
{
	if ( GetFeatureValue(CUSTOM_MENU) )
	{
		// Custom Menu overrides Simple Menu
		SetFeatureValue(SIMPLE_MENU, FALSE);
	}

	if ( GetFeatureValue(CUSTOM_MENU) || GetFeatureValue(SIMPLE_MENU) )
	{
		// The following features are not used when using the alternate menus
		// Disable them when we go to generate the features file so we don't have
		// any extra confusion in the file
		ClearINOFeatures();
		SetFeatureValue(DOSING_INTERVAL_SETUP, FALSE);
		SetFeatureValue(OVERHEAT_SETUP, FALSE);
		SetFeatureValue(SETUP_EXTRAS, FALSE);
	}
}

void CFeatures::ClearINOFeatures()
{
	SetFeatureValue(STANDARD_LIGHT_SETUP, FALSE);
	SetFeatureValue(METAL_HALIDE_SETUP, FALSE);
	SetFeatureValue(ATO_SETUP, FALSE);
	SetFeatureValue(DOSING_PUMP_SETUP, FALSE);
	SetFeatureValue(WAVEMAKER_SETUP, FALSE);
	SetFeatureValue(SINGLE_ATO, FALSE);
}

BOOL CFeatures::IsCustomMenu() 
{
	return (GetFeatureValue(SIMPLE_MENU) || GetFeatureValue(CUSTOM_MENU) );
}

CString CFeatures::GetEnabledList()
{
	// loop through all the features
	// if the value is TRUE, then add "#define " in front of the sDefine value
	CString s = _T("");
	CString sCRLF;
	sCRLF.LoadString(IDS_CRLF);
	for ( int i = 1; i < MAX_FEATURES; i++ )
	{
		if ( m_fd[i].fValue )
		{
			s += _T("#define ") + m_fd[i].sDefine + sCRLF;
			// for these special scenarios, we need to add on the additional values
			if ( i == CUSTOM_MENU )
			{
				CString s1;
				s1.Format(_T("#define CUSTOM_MENU_ENTRIES %d%s"), iCustomMenuEntries, sCRLF);
				s += s1;
			} else if ( i == EXPANSION_MODULE )
			{
				CString s1;
				s1.Format(_T("#define InstalledRelayExpansionModules %d%s"), iInstalledExpansionModules, sCRLF);
				s += s1;
			}
		}
	}
	return s;
}

UINT CFeatures::GetFeatureStringID(int index)
{
	if ( (index < 0) || (index >= MAX_FEATURES) )
	{
		TRACE("FeatureStringID: INVALID INDEX = %d\n", index);
		return 0;
	}
	return m_fd[index].uStringID;
}

CString CFeatures::GetFeatureDefine(int index)
{
	if ( (index < 0) || (index >= MAX_FEATURES) )
	{
		TRACE("FeatureDefine: INVALID INDEX = %d\n", index);
		return _T("");
	}
	return m_fd[index].sDefine;
}

BOOL CFeatures::GetFeatureValue(int index)
{
	if ( (index < 0) || (index >= MAX_FEATURES) )
	{
		TRACE("FeatureValue: INVALID INDEX = %d\n", index);
		return FALSE;
	}
	return m_fd[index].fValue;
}

void CFeatures::SetFeatureValue(int index, BOOL fValue)
{
	if ( (index < 0) || (index >= MAX_FEATURES) )
	{
		TRACE("SetFeatureValue: INVALID INDEX = %d\n", index);
		return;
	}
	m_fd[index].fValue = fValue;
}

// Private functions
void CFeatures::InitFeatureData()
{
	SetFeatureData(NONE, 0, _T(""));
	SetFeatureData(DISPLAY_IMAGES, IDS_FEATURES_DISPLAYIMAGES, _T("DisplayImages"), TRUE);
	SetFeatureData(SETUP_EXTRAS, IDS_FEATURES_SETUPEXTRAS, _T("SetupExtras"));
	SetFeatureData(DOSING_PUMP_SETUP, 0, _T("DosingPumpSetup"));
	SetFeatureData(WAVEMAKER_SETUP, 0, _T("WavemakerSetup"));
	SetFeatureData(OVERHEAT_SETUP, IDS_FEATURES_OVERHEATSETUP, _T("OverheatSetup"));
	SetFeatureData(DATE_TIME_SETUP, IDS_FEATURES_DATETIMESETUP, _T("DateTimeSetup"), TRUE);
	SetFeatureData(VERSION_MENU, IDS_FEATURES_VERSIONMENU, _T("VersionMenu"), TRUE);
	SetFeatureData(ATO_SETUP, 0, _T("ATOSetup"));
	SetFeatureData(METAL_HALIDE_SETUP, 0, _T("MetalHalideSetup"));
	SetFeatureData(DIRECT_TEMP_SENSOR, IDS_FEATURES_DIRECTTEMPSENSOR, _T("DirectTempSensor"), TRUE);
	SetFeatureData(DISPLAY_LED_PWM, IDS_FEATURES_DISPLAYLEDPWM, _T("DisplayLEDPWM"), TRUE);
	SetFeatureData(WIFI, IDS_FEATURES_WIFI, _T("wifi"), TRUE);
	SetFeatureData(SINGLE_ATO, 0, _T("SingleATOSetup"));
	SetFeatureData(STANDARD_LIGHT_SETUP, 0, _T("StandardLightSetup"));
	SetFeatureData(REMOVE_ALL_LIGHTS, IDS_FEATURES_REMOVEALLLIGHTS, _T("RemoveAllLights"));
	SetFeatureData(SAVE_RELAY_STATE, IDS_FEATURES_SAVERELAYSTATE, _T("SaveRelayState"));
	SetFeatureData(EXPANSION_MODULE, IDS_FEATURES_EXPANSIONMODULE, _T("RelayExp"));
	SetFeatureData(DOSING_INTERVAL_SETUP, IDS_FEATURES_DOSINGINTERVALSETUP, _T("DosingPumpIntervalSetup"));
	SetFeatureData(WDT, IDS_FEATURES_WDT, _T("WDT"));
	SetFeatureData(CUSTOM_MENU, IDS_FEATURES_CUSTOMMENU, _T("CUSTOM_MENU"));
	SetFeatureData(SIMPLE_MENU, IDS_FEATURES_SIMPLEMENU, _T("SIMPLE_MENU"), TRUE);
	SetFeatureData(PWM_EXPANSION, IDS_FEATURES_PWMEXPANSION, _T("PWMEXPANSION"));
	SetFeatureData(CUSTOM_MAIN, IDS_FEATURES_CUSTOMMAIN, _T("CUSTOM_MAIN"));
	SetFeatureData(CUSTOM_COLORS, IDS_FEATURES_COLORSPDE, _T("COLORS_PDE"));
	SetFeatureData(ATO_LOGGING, IDS_FEATURES_ATOLOGGING, _T("ENABLE_ATO_LOGGING"));
	SetFeatureData(EXCEED_FLAGS, IDS_FEATURES_EXCEEDFLAG, _T("ENABLE_EXCEED_FLAGS"));
	SetFeatureData(SALINITY, IDS_FEATURES_SALINITY, _T("SALINITYEXPANSION"));
	SetFeatureData(RF, IDS_FEATURES_RF, _T("RFEXPANSION"));
	SetFeatureData(ORP, IDS_FEATURES_ORP, _T("ORPEXPANSION"));
	SetFeatureData(IO, IDS_FEATURES_IO, _T("IOEXPANSION"));
	SetFeatureData(AI, IDS_FEATURES_AILED, _T("AI_LED"));
	SetFeatureData(FONT_8x8, IDS_FEATURES_FONT_8X8, _T("FONT_8x8"));
	SetFeatureData(FONT_8x16, IDS_FEATURES_FONT_8X16, _T("FONT_8x16"));
	SetFeatureData(FONT_12x16, IDS_FEATURES_FONT_12X16, _T("FONT_12x16"));
	SetFeatureData(NUMBERS_8x8, IDS_FEATURES_NUMBERS_8X8, _T("NUMBERS_8x8"));
	SetFeatureData(NUMBERS_8x16, IDS_FEATURES_NUMBERS_8X16, _T("NUMBERS_8x16"));
	SetFeatureData(NUMBERS_12x16, IDS_FEATURES_NUMBERS_12X16, _T("NUMBERS_12x16"));
	SetFeatureData(NUMBERS_16x16, IDS_FEATURES_NUMBERS_16X16, _T("NUMBERS_16x16"));
	SetFeatureData(CUSTOM_VARIABLES, IDS_FEATURES_CUSTOMVARIABLES, _T("CUSTOM_VARIABLES"));
}

void CFeatures::SetFeatureData(int index, UINT stringID, CString sDefine, BOOL fValue /*= FALSE*/)
{
	m_fd[index].uStringID = stringID;
	m_fd[index].sDefine = sDefine;
	m_fd[index].fValue = fValue;
}

void CFeatures::ProcessFeature(CString sFeature, CString sValue /*= _T("")*/)
{
	for ( int i = 1; i < MAX_FEATURES; i++ )
	{
		// we found the matching define
		if ( sFeature == m_fd[i].sDefine )
		{
			m_fd[i].fValue = TRUE;
			break;
		}
	}

	if ( (sFeature == _T("WDT_FORCE")) || 
		 (sFeature == _T("__PLUS_SPECIAL_WIFI__")) )
	{
		// add the unknown feature to the list
		CString s;
		s.Format(_T("#define %s\r\n"), sFeature.GetBuffer());
		m_sUnknown += s;
	} else if ( sFeature == _T("__REEFANGEL_FEATURES__") )
	{
		// skip
	} else if ( sFeature == _T("InstalledRelayExpansionModules") )
	{
		iInstalledExpansionModules = atoi(sValue);
		if ( (iInstalledExpansionModules < 0) ||
			 (iInstalledExpansionModules > MAX_PORTS) )
		{
			iInstalledExpansionModules = 0;
		}
	} else if ( (sFeature == _T("PWMExpansion")) ||		// old style
			    (sFeature == _T("PWMExpansionRelay")) ) // old style
	{
		// look for the older style expansion defines
		SetFeatureValue(PWM_EXPANSION, TRUE);
	} else if ( sFeature == _T("CUSTOM_MENU_ENTRIES") )
	{
		iCustomMenuEntries = atoi(sValue);
		if ( (iCustomMenuEntries < MENU_MIN) ||
			 (iCustomMenuEntries > MENU_MAX) )
		{
			iCustomMenuEntries = MENU_DEFAULT;
		}
	}
}
